# Завдання 1 — Перевірка унікальності паролів за допомогою фільтра Блума

Ця частина проєкту реалізує **фільтр Блума** для перевірки, чи використовувався пароль раніше, без необхідності зберігати всі паролі явно.

---

## Файл

- `bloom_filter_passwords.py` — основний скрипт із реалізацією фільтра Блума та прикладом використання.

---

## Реалізований функціонал

### 1. Клас `BloomFilter`

Клас інкапсулює логіку роботи фільтра Блума.

**Параметри конструктора**:

- `size: int` — розмір бітового масиву;
- `num_hashes: int` — кількість хеш-функцій.

**Внутрішнє подання**:

- бітовий масив реалізовано як список цілих `0/1` довжини `size`.

**Основні методи**:

- `_normalize(item)` — перетворює будь-яке значення на рядок (включно з `None`);
- `_hashes(item)` — генерує `num_hashes` різних хешів для елемента на основі `hashlib.sha256`;
- `add(item)` — додає елемент до фільтра (встановлює відповідні біти у `1`);
- `__contains__(item)` — перевірка належності елемента  
  (`item in bloom_filter` → `True` / `False`):
  - якщо хоча б один відповідний біт дорівнює `0` — елемент **точно відсутній**;
  - якщо всі біти `1` — елемент **можливо присутній** (можливі фальш-позитиви).

---

### 2. Функція `check_password_uniqueness(bloom, new_passwords)`

Функція перевіряє список паролів на унікальність, використовуючи переданий `BloomFilter`.

**Параметри**:

- `bloom: BloomFilter` — екземпляр фільтра Блума з уже доданими існуючими паролями;
- `new_passwords: Iterable[Any]` — колекція нових паролів для перевірки.

**Поведінка**:

- для кожного пароля:
  - якщо пароль **вже є** у фільтрі → статус _«вже використаний»_;
  - якщо **немає** → статус _«унікальний»_ і пароль додається до фільтра;
- усі значення (включно з `None` або числами) приводяться до рядка.

**Повертає**:

- словник виду:

```python
{
    "password123": "вже використаний",
    "newpassword": "унікальний",
    ...
}
```

---

## Приклад використання

У файлі `bloom_filter_passwords.py`:

```python
if __name__ == "__main__":
    # Ініціалізація фільтра Блума
    bloom = BloomFilter(size=1000, num_hashes=3)

    # Додавання існуючих паролів
    existing_passwords = ["password123", "admin123", "qwerty123"]
    for password in existing_passwords:
        bloom.add(password)

    # Перевірка нових паролів
    new_passwords_to_check = ["password123", "newpassword", "admin123", "guest"]
    results = check_password_uniqueness(bloom, new_passwords_to_check)

    # Виведення результатів
    for password, status in results.items():
        print(f"Пароль '{password}' — {status}.")
```

Очікуваний вивід:

```text
Пароль 'password123' — вже використаний.
Пароль 'newpassword' — унікальний.
Пароль 'admin123' — вже використаний.
Пароль 'guest' — унікальний.
```

---

## Як запустити

З кореня репозиторію:

```bash
cd task_1_bloom_filter
python3 bloom_filter_passwords.py
```

---

## Призначення завдання

Завдання демонструє:

- як перевіряти унікальність елементів без збереження всього набору даних;
- використання ймовірнісної структури даних **Bloom Filter**;
- основи економії пам’яті за рахунок допустимих фальш-позитивів.